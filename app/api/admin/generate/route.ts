import { NextResponse } from "next/server";
import { generateText } from "ai";
import { gateway } from "@ai-sdk/gateway";
import { openai } from "@ai-sdk/openai";
import { generatedSiteDataSchema } from "@/lib/admin/schemas";
import { getMusicSystemPrompt, getSportsSystemPrompt } from "@/lib/admin/prompts";
import { fetchDiscogsLabelData } from "@/lib/admin/fetch-discogs-label";
import { fetchDiscogsArtistData } from "@/lib/admin/fetch-discogs-artist";

const ADMIN_PASSCODE = "6231839";

function validatePasscode(request: Request): boolean {
  return request.headers.get("x-admin-passcode") === ADMIN_PASSCODE;
}

export const maxDuration = 120;

export async function POST(request: Request) {
  if (!validatePasscode(request)) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const body = await request.json();
    const { siteType, musicSubtype, siteId, siteName, content, extractedText, logoPaths, discogsLabelId, discogsArtistId } = body;

    if (!siteType || !siteId || !siteName) {
      return NextResponse.json(
        { error: "siteType, siteId, and siteName are required" },
        { status: 400 },
      );
    }

    const systemPrompt =
      siteType === "music" ? getMusicSystemPrompt() : getSportsSystemPrompt();

    const userContent = [
      `Site Type: ${siteType}`,
      musicSubtype ? `Music Subtype: ${musicSubtype} (use "${musicSubtype === "label" ? "Related Labels" : "Side Projects"}" for navLabels.sideProjects)` : "",
      `Site ID: ${siteId}`,
      `Site Name: ${siteName}`,
      "",
      "--- User-Provided Content ---",
      content || "(no content provided)",
      "",
      extractedText ? `--- Extracted File Content ---\n${extractedText}` : "",
      "",
      logoPaths?.length ? `Logo paths: ${logoPaths.join(", ")}` : "",
      "",
      "Generate the complete site data JSON now.",
    ]
      .filter(Boolean)
      .join("\n");

    const model = process.env.OPENAI_API_KEY
      ? openai("gpt-4o-mini")
      : gateway("openai/gpt-4o-mini");

    const result = await generateText({
      model,
      system: systemPrompt,
      messages: [{ role: "user", content: userContent }],
      maxTokens: 16000,
    });

    // Parse and validate the response
    let parsed: unknown;
    try {
      // Strip markdown fences if present
      let text = result.text.trim();
      if (text.startsWith("```")) {
        text = text.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "");
      }
      parsed = JSON.parse(text);
    } catch {
      return NextResponse.json(
        { error: "AI returned invalid JSON", raw: result.text },
        { status: 422 },
      );
    }

    // Fix common AI mistakes before validation
    const VALID_CATEGORIES = new Set(["history", "artists", "releases", "facts"]);
    if (parsed && typeof parsed === "object" && "trivia" in parsed && Array.isArray((parsed as any).trivia)) {
      for (const q of (parsed as any).trivia) {
        if (q && typeof q.category === "string" && !VALID_CATEGORIES.has(q.category)) {
          q.category = "facts";
        }
        // Ensure exactly 4 options
        if (q && Array.isArray(q.options)) {
          while (q.options.length < 4) q.options.push("None of the above");
          if (q.options.length > 4) q.options = q.options.slice(0, 4);
        }
      }
    }

    const validation = generatedSiteDataSchema.safeParse(parsed);
    if (!validation.success) {
      return NextResponse.json(
        {
          error: "AI output failed validation",
          issues: validation.error.issues,
          raw: parsed,
        },
        { status: 422 },
      );
    }

    let finalData = validation.data;

    // Override navLabels.sideProjects based on musicSubtype
    if (musicSubtype) {
      finalData.config.navLabels.sideProjects =
        musicSubtype === "label" ? "Related Labels" : "Side Projects";
    }

    // Force membersSlug and albumsSlug to match the actual route directories
    // generated by generate-site-files.ts (always "artists/" and "releases/").
    // GBV is the only site with "members"/"albums" slugs and it's hardcoded.
    finalData.config.membersSlug = "artists";
    finalData.config.albumsSlug = "releases";

    // Force navLabels.members to match the membersSlug for artist/label sites
    if (musicSubtype === "label") {
      finalData.config.navLabels.members = "Artists";
    } else if (musicSubtype === "artist") {
      finalData.config.navLabels.members = "Members";
    }

    // If discogsLabelId is present and we have a token, fetch exhaustive discography
    const discogsToken = process.env.DISCOGS_USER_TOKEN || process.env.DISCOGS_TOKEN;
    const resolvedDiscogsLabelId =
      discogsLabelId ? Number(discogsLabelId) : finalData.config.discogsLabelId;
    if (resolvedDiscogsLabelId && discogsToken) {
      try {
        console.log(`[ADMIN] Fetching Discogs label ${resolvedDiscogsLabelId}...`);
        finalData.config.discogsLabelId = resolvedDiscogsLabelId;
        const discogsData = await fetchDiscogsLabelData(
          resolvedDiscogsLabelId,
          discogsToken,
        );
        // Replace AI-generated artists/releases with exhaustive Discogs data
        // Keep AI-generated trivia, timeline, knowledge, recordFacts
        finalData = {
          ...finalData,
          artists: discogsData.artists,
          releases: discogsData.releases,
        };
        console.log(
          `[ADMIN] Merged Discogs data: ${discogsData.artists.length} artists, ${discogsData.releases.length} releases`,
        );
      } catch (discogsError) {
        console.warn(
          "[ADMIN] Discogs label fetch failed, using AI-generated data:",
          discogsError instanceof Error ? discogsError.message : discogsError,
        );
      }
    }

    // If discogsArtistId is present, fetch artist members + discography
    const resolvedDiscogsArtistId =
      discogsArtistId ? Number(discogsArtistId) : finalData.config.discogsArtistId;
    if (resolvedDiscogsArtistId && discogsToken) {
      try {
        console.log(`[ADMIN] Fetching Discogs artist ${resolvedDiscogsArtistId}...`);
        const discogsData = await fetchDiscogsArtistData(
          resolvedDiscogsArtistId,
          discogsToken,
        );
        finalData = {
          ...finalData,
          artists: discogsData.artists,
          releases: discogsData.releases,
        };
        // Store the artist ID in config
        finalData.config.discogsArtistId = resolvedDiscogsArtistId;
        console.log(
          `[ADMIN] Merged Discogs artist data: ${discogsData.artists.length} members, ${discogsData.releases.length} releases`,
        );
      } catch (discogsError) {
        console.warn(
          "[ADMIN] Discogs artist fetch failed, using AI-generated data:",
          discogsError instanceof Error ? discogsError.message : discogsError,
        );
      }
    }

    // Log token usage
    if (result.usage) {
      console.log(
        `[ADMIN] Token usage â€” prompt: ${result.usage.promptTokens}, completion: ${result.usage.completionTokens}, total: ${result.usage.totalTokens}`,
      );
    }

    return NextResponse.json(finalData);
  } catch (error) {
    console.error("[ADMIN] Generate error:", error);
    return NextResponse.json(
      { error: "Generation failed", details: error instanceof Error ? error.message : "Unknown error" },
      { status: 500 },
    );
  }
}
